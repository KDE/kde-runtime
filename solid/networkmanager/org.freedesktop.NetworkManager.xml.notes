NM_DBUS_SERVICE "org.freedesktop.NetworkManager"
NM_DBUS_PATH "/org/freedesktop/NetworkManager"
NM_DBUS_INTERFACE "org.freedesktop.NetworkManager"
NM_DBUS_PATH_DEVICES "/org/freedesktop/NetworkManager/Devices"
NM_DBUS_INTERFACE_DEVICES "org.freedesktop.NetworkManager.Devices"
NM_DBUS_PATH_DHCP "/org/freedesktop/NetworkManager/DhcpOptions"
NM_DBUS_INTERFACE_DHCP "org.freedesktop.NetworkManager.DhcpOptions"

NMI_DBUS_SERVICE "org.freedesktop.NetworkManagerInfo"
NMI_DBUS_PATH "/org/freedesktop/NetworkManagerInfo"
NMI_DBUS_INTERFACE "org.freedesktop.NetworkManagerInfo"

### DBus housekeeping stuff ###
msg, DBUS_INTERFACE_LOCAL, "Disconnected"
DBUS_INTERFACE_DBUS, "NameOwnerChanged" s service s oldowner s newowner // dbus restarted
DBUS_INTERFACE_DBUS, "NameAcquired" // probably tells us that we got the NetworkManagerInfo name for ourselves, see NetworkManagerInfoDBus::requestName

### General ###
## getters ##
NM_DBUS_SERVICE, NM_DBUS_PATH, NM_DBUS_INTERFACE, "state" returns uint32 state
NM_DBUS_SERVICE, NM_DBUS_PATH, NM_DBUS_INTERFACE_DEVICES, "getDevices" returns returns NM_DBUS_NO_DEVICES_ERROR or aop objpath i num_devices
NM_DBUS_SERVICE, net_path, NM_DBUS_INTERFACE_DEVICES, "getProperties" return Network struct, see DeviceStoreDBus::updateNetworkCallback
NM_DBUS_SERVICE, NM_DBUS_PATH, NM_DBUS_INTERFACE, "getWirelessEnabled" returns bool
## setters ##
NM_DBUS_SERVICE, NM_DBUS_PATH, NM_DBUS_INTERFACE, "setActiveDevice op objpath // used for wired interfaces
NM_DBUS_SERVICE, NM_DBUS_PATH, NM_DBUS_INTERFACE, "setActiveDevice op objpath s essid b fallback THEN [encoding]
NM_DBUS_SERVICE, NM_DBUS_PATH, NM_DBUS_INTERFACE, "setWirelessEnabled" boolean returns ?
NM_DBUS_SERVICE, NM_DBUS_PATH, NM_DBUS_INTERFACE, "sleep"
NM_DBUS_SERVICE, NM_DBUS_PATH, NM_DBUS_INTERFACE, "wake"
# Device
NM_DBUS_SERVICE, obj_path, NM_DBUS_INTERFACE_DEVICES, "getProperties" returns Device struct, see DeviceStoreDBus::updateDeviceCallback
getName returns s interfacename
getType returns int32 type
getHalUdi returns s udi
getIP4Address returns uint32 ip_address
getHWAddress returns s hwaddr
getMode returns int32 mode
getActiveNetwork returns o net_path, or Error DeviceNotWireless or Error NoActiveNetwork 
getNetworks returns ao or error NoNetworks or Error DeviceNotWireless
getLinkActive returns bool
setLinkActive bool // only usable on fake, test devices, returns NotTestDevice error otherwise
getCapabilities returns uint capabilities
getDriver returns s drivername

## signals ##
NM_DBUS_INTERFACE, NM_DBUS_SIGNAL_STATE_CHANGE uint32 state

# Device
DeviceStrengthChanged (o obj_path, int32 strength)

DeviceCarrierOn dev_path
DeviceCarrierOff dev_path
DeviceAdded dev_path
NM_DBUS_INTERFACE, "DeviceRemoved" op obj_path
DeviceNoLongerActive o dev_path
DeviceNowActive o dev_path
DeviceActivating o dev_path
DeviceActivationFailed o dev_path, + s essid if wireless FUCKERS

NM_DBUS_INTERFACE, "WirelessNetworkAppeared" op obj_path op net_path
NM_DBUS_INTERFACE, "WirelessNetworkDisappeared"  op obj_path op net_path
NM_DBUS_INTERFACE, "WirelessNetworkStrengthChanged" op obj_path op net_path int32 strength
NM_DBUS_INTERFACE, "DeviceActivationStage" op obj_path uint32 stage
    NM_ACT_STAGE_UNKNOWN = 0,
	NM_ACT_STAGE_DEVICE_PREPARE,
	NM_ACT_STAGE_DEVICE_CONFIG,
	NM_ACT_STAGE_NEED_USER_KEY,
	NM_ACT_STAGE_IP_CONFIG_START,
	NM_ACT_STAGE_IP_CONFIG_GET,
	NM_ACT_STAGE_IP_CONFIG_COMMIT,
	NM_ACT_STAGE_ACTIVATED,
	NM_ACT_STAGE_FAILED,
	NM_ACT_STAGE_CANCELLED

// after DeviceActivationFailed, need to update device and possibly network to get the right activation stage.


### Dialup ###
## getters ##
NM_DBUS_SERVICE, NM_DBUS_PATH, NM_DBUS_INTERFACE_DEVICES, "getDialup" returns NM_DBUS_NO_DIALUP_ERROR or as dialups i num_dialups
## setters ##
NM_DBUS_SERVICE, NM_DBUS_PATH, NM_DBUS_INTERFACE, "activateDialup s dialupname
NM_DBUS_SERVICE, NM_DBUS_PATH, NM_DBUS_INTERFACE, "deactivateDialup s dialupname

### VPN ###
## getters ##
NM_DBUS_SERVICE, NM_DBUS_PATH_VPN, NM_DBUS_INTERFACE_VPN, "getVPNConnectionProperties" s name returns vpn struct, [s name, s user, s service_name, uint32 stage]
## setters ##
NM_DBUS_SERVICE, NM_DBUS_PATH_VPN, NM_DBUS_INTERFACE_VPN, "activateVPNConnection" s name, as passwords
NM_DBUS_SERVICE, NM_DBUS_PATH_VPN, NM_DBUS_INTERFACE_VPN, "deactivateVPNConnection"
## signals ##
NM_DBUS_INTERFACE_VPN, "VPNConnectionAdded" s name
NM_DBUS_INTERFACE_VPN, "VPNConnectionUpdate" s name
NM_DBUS_INTERFACE_VPN, "VPNConnectionStateChange" s name uint32 stage
NM_DBUS_INTERFACE_VPN, NM_DBUS_VPN_SIGNAL_LOGIN_FAILED s name s errormsg
NM_DBUS_INTERFACE_VPN, NM_DBUS_VPN_SIGNAL_LAUNCH_FAILED s name s errormsg
NM_DBUS_INTERFACE_VPN, NM_DBUS_VPN_SIGNAL_CONNECT_FAILED s name s errormsg
NM_DBUS_INTERFACE_VPN, NM_DBUS_VPN_SIGNAL_VPN_CONFIG_BAD s name s errormsg
NM_DBUS_INTERFACE_VPN, NM_DBUS_VPN_SIGNAL_IP_CONFIG_BAD s name s errormsg

### NetworkManagerInfo ###
signals:
NMI_DBUS_PATH, NMI_DBUS_INTERFACE, "VPNConnectionUpdate"
NMI_DBUS_PATH, NMI_DBUS_INTERFACE, "UserInterfaceActivated" // we emit this signal and NM does what?

// probably this sets up the NMI object
Â·   if (dbus_connection_register_object_path (_dbus_connection, NMI_DBUS_PATH, &vtable, _ctx)) {

slots on NMInfo object
getKeyForNetwork op dev_path op net_path s essid i attempt b new_key, returns[encoding] or .GetKeyError
cancelGetKeyForNetwork
getNetworks void, returns as essids
getNetworkProperties s essid, returns s essid, int32 timestamp b trusted, as hwaddrs, [encryption]
R .NoNetworks
updateNetworkInfo s essid b automatic s bssid int32 we_cipher // what's this method do again? no reply.
getVPNConnections void, returns as name or NM_DBUS_NO_VPN_CONNECTIONS
getVPNConnectionProperties s name returns s name s service s user OR NM_DBUS_INVALID_VPN_CONNECTION
getVPNConnectionVPNData s name, returns as data OR NM_DBUS_INVALID_VPN_CONNECTION
getVPNConnectionRoutes s name, returns as routes OR NM_DBUS_INVALID_VPN_CONNECTION

### Security ###
FIRST
int32 cipher { 
IW_AUTH_CIPHER_WEP40:
IW_AUTH_CIPHER_WEP104:
{
  //also cipher dependent?
  s key
  int32 authentication algorithm => {IW_AUTH_ALG_OPEN_SYSTEM,IW_AUTH_ALG_SHARED_KEY}
}
NM_AUTH_TYPE_WPA_PSK_AUTO:
IW_AUTH_CIPHER_TKIP:
IW_AUTH_CIPHER_CCMP:
{
  s key
  int32 wpa version =>{IW_AUTH_WPA_VERSION_WPA,IW_AUTH_WPA_VERSION_WPA2}
  int32 key mgmt => {IW_AUTH_KEY_MGMT_802_1X,IW_AUTH_KEY_MGMT_PSK}
}
NM_AUTH_TYPE_WPA_EAP:
{
  int32 eap method => {NM_EAP_METHOD_MD5,NM_EAP_METHOD_MSCHAP,NM_EAP_METHOD_OTP,NM_EAP_METHOD_GTC,NM_EAP_METHOD_PEAP,NM_EAP_METHOD_TLS,NM_EAP_METHOD_TTLS}
  int32 key type => {NM_AUTH_TYPE_WPA_PSK_AUTO,IW_AUTH_CIPHER_CCMP,IW_AUTH_CIPHER_TKIP,IW_AUTH_CIPHER_WEP104}
  s identity
  s password
  s anon identity
  s priv key password
  s priv key file
  s client cert file
  s ca cert file
  int32 wpa version => {IW_AUTH_WPA_VERSION_WPA,IW_AUTH_WPA_VERSION_WPA2}
}
NM_AUTH_TYPE_LEAP:
{
  s username
  s password
  s key mgmt
}
