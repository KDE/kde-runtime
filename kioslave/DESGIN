What is a kioslave you ask yourself?

A kioslave is a program designed to be intimately familiar with a certian
protocol, so that a standardized interface can be used to get at data from
any number of places.  A few examples are the http and ftp kioslaves,
which using nearly identical methods will retrieve data from an http or
ftp server respectively.

Well, that's nice.  How do they work?

To understand it, you'll need two ice cubes, a pair of handcuffs, and a
ferret.  Some Crisco (or other shortening) is optional.  Well, that aside,
this document focuses on the business end of the whole kio library.  The
ioslave.  Any basic kioslave will have these public methods:

  ctor ( Connection *_conn );
	The constructor, handles initialization, and initializes the base
	class IOProtocol w/ the Connection pointer.

  virtual dtor() { }
	The destructor.  Pretty much does what you think.  It's a sweeper
	of sorts.

  virtual bool error( int _err, const char *_txt );
	Handles errors in a standard way.  Usually IOProtocol::error is
	called to pop up a message box.

  void jobError( int _errid, const char *_txt );
	Similar to ::error().

  Connection* connection();

Your standard get (read) only slave has three public methods:

  virtual void slotGet( const char *_url );
	This is essentially a Qt style slot, and thus doesn't return
	anything of value.  Before any data is "emitted" the read()
	member must be called, and a mimetype should be emitted via
	the mimeType method which takes a c/qstring as its only argument.
	Following this, the gettingFile(c/qstring) member must be called.
	The gettingFile(c/qstring) indicates the name of the URI being
	accessed. Then comes totalSize(), canResume(bool). Next a Data is
	emitted via the data(void *, s_int) member, which takes a void
	pointer that's holding the data, and a signed integer representing
	the length, the processedSize(unsigned long) member should also be
	called with the total amount of data that's been sent for this
	job, also the speed(u_long) member can be useful taking the bytes
	per second as its argument.... My experience has shown that using
	data > 2048 bytes tends not to work.  When finished, the
	dataEnd(), and finished() members must be called.

  virtual void slotGetSize( const char *_url );
	Again this doesn't return anything, but does usually send out
	the total size via the totalSize member, which takes one unsigned
	long argument.

  virtual void slotCopy( const char *_source, const char *_dest );
	Used by such progams as Caitoo, instead of gettingFile you'll want
	to use copyingFile().	

IF YOU'RE STILL READING THIS AND ARE INTERESTED IN WORKING ON AN IOSLAVE,
AS OF April 28th, THE FOLLOWING SLAVES ARE SEVERLY LACKING IN
FUNCTIONALITY:

	IMAP4 (Perhaps imap2 support should be added)
	TAR
	
If those don't suit you perhaps you'd be interested in adding a slave for:

	BZIP2
